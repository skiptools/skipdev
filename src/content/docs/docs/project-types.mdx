---
title: Project Structure
permalink: /docs/project-types/
---
import { FileTree } from '@astrojs/starlight/components';

## Conventional Skip Projects

A Skip app project is one that is created with `skip init` or `skip create`. At its essence, it is a standard [Swift Package Manager project](https://docs.swift.org/swiftpm/documentation/packagemanagerdocs/introducingpackages), with a top-level `Package.swift` and directories for `Sources/` and `Tests/`.

Skip augments this structure by adding shared `Skip.env` metadata and `Darwin/` and `Android/` sub-folders that house the build systems for their respective platforms along with platform-specific metadata and deployment information.

:::tip
A Skip project is a strict superset of a conventional SwiftPM package, and can be included as a dependency of any other Swift package _regardless of whether or not they use Skip_.
:::

A Skip project can be built locally with `swift build` and tested with `swift test`. In addition, Skip-specific commands like `skip export` can be used to build the platform-specific binaries (`.ipa` for iOS and `.apk` for Android) for distribution through the various app stores.

### Samples

There are three standard examples that can be perused that illustrate the makeup of a conventional Skip project:

1. [HelloSkip](/docs/samples/skipapp-hello/): A basic example of a transpiled Skip Lite project.
2. [HowdySkip](/docs/samples/skipapp-howdy/): A basic example of a compiled Skip Fuse project.
3. [HiyaSkip](/docs/samples/skipapp-hiya/): An example of a Skip project that uses a compiled (Skip Fuse) UI module bridging to a transpiled (Skip Lite) model layer module.

## Filesystem Layout

Consider an "Ahoy Skipper" Skip Fuse app with two modules and test cases that can be generated with the following `skip init` command (or the equivalent `skip create` interactive command):

```console
skip init --native-app --bridged --module-tests --show-tree --appid=ahoy.skipper ahoy-skipper AhoySkipper SkipperModel
```

An abridged view of the filesystem layout of the app will look like this:

<FileTree>
 - README.md
 - [Skip.env](#Skip.env) App metadata (name, version, appid, etc.)
 - [Package.swift](#Package.swift) Standard SwiftPM build file
 - [Project.xcworkspace](#Project.xcworkspace) Xcode workspace container for Darwin project
 - Sources
    - AhoySkipper App module with SwiftUI source
       - [AhoySkipperApp.swift](#App.swift) App entry point
       - [ContentView.swift](#ContentView.swift) Top-level SwiftUI view
       - Resources
          - [Localizable.xcstrings](#Localizable.xcstrings) Localized UI strings
          - [Module.xcassets](#Module.xcassets) Images and other resources
       - Skip
          - [skip.yml](#skip.yml) Skip module configuration
    - SkipperModel Model code used by `AhoySkipper`
       - [ViewModel.swift](#ViewModel.swift) Observable model code
       - Resources
          - [Localizable.xcstrings](#Localizable.xcstrings) Localized model strings
       - Skip
          - [skip.yml Skip](#skip.yml) module configuration
 - Tests
    - SkipperModelTests
       - [SkipperModelTests.swift](#SkipperModelTests.swift) XCUnit test cases
       - Resources
          - TestData.json Test data
       - Skip
          - [skip.yml](#skip.yml) Skip module configuration
 - Android
    - gradle.properties
    - [settings.gradle.kts](#settings.gradle.kts) Top-level Gradle configuration
    - app
       - [build.gradle.kts](#build.gradle.kts) Gradle build file
       - [proguard-rules.pro](#proguard-rules.pro) [R8 configuration](https://developer.android.com/topic/performance/app-optimization/enable-app-optimization)
       - src
          - main
             - [AndroidManifest.xml](#AndroidManifest.xml) Android app metadata
             - kotlin
                - [Main.kt](#Main.kt) Entry point for Android app
             - res
                - mipmap-hdpi Android app icon
                   - [ic_launcher.png](#ic_launcher.png)
                   - …
                - …
    - fastlane configuration for [upload_to_app_store](https://docs.fastlane.tools/actions/upload_to_app_store/)
       - [Appfile](#Android/fastlane/Appfile)
       - Fastfile
       - metadata
          - android
             - en-US
                - title.txt
                - short_description.txt
                - full_description.txt
                - …
 - Darwin
    - [AhoySkipper.xcconfig](#ProjectName.xcconfig) Xcode build configuration
    - [AhoySkipper.xcodeproj](#ProjectName.xcodeproj) Xcode project
    - [Assets.xcassets](#Assets.xcassets) iOS app assets
       - AppIcon.appiconset iOS app icon
          - [AppIcon.png](#AppIcon.png)
          - …
    - [Entitlements.plist](#Entitlements.plist) iOS permissions
    - [Info.plist](#Info.plist) iOS app metadata
    - Sources
       - [Main.swift](#Main.swift) Entry point for Darwin app
    - fastlane configuration for [upload_to_play_store](https://docs.fastlane.tools/actions/upload_to_play_store/)
       - [Appfile](#Darwin/fastlane/Appfile)
       - Deliverfile
       - Fastfile
       - metadata
          - app_privacy_details.json
          - rating.json
          - en-US
             - title.txt
             - subtitle.txt
             - description.txt
             - …
</FileTree>

### `Package.swift` {#Package.swift}

This file is the manifest for the Swift Package Manager (SwiftPM). It defines the project's name, products (libraries or executables), dependencies, and targets. In a Skip project, it also declares the `skipstone` plugin, which handles the transpilation of Swift code into Kotlin for Android.

- Reference: [Swift Package Manager - Package.swift Manifest](https://docs.swift.org/swiftpm/documentation/packagemanagerdocs/introducingpackages)

### `Project.xcworkspace` {#Project.xcworkspace}

This file is an Xcode Workspace, a container used to group multiple Xcode projects and Swift packages together. In Skip, it allows you to manage the primary Darwin app project alongside the shared Swift modules in a single interface, ensuring that shared code changes are immediately reflected in the app build.

- Reference: [Xcode Help - Workspace Concepts](https://developer.apple.com/documentation/xcode/managing-multiple-projects-and-their-dependencies)

### `Skip.env` {#Skip.env}

This is a shared configuration environment file for Skip projects. It contains key-value pairs for project-wide metadata, such as the `PRODUCT_NAME`, `MARKETING_VERSION`, and `PRODUCT_BUNDLE_IDENTIFIER`. These variables are used by both the Xcode build process and the Gradle build process to ensure consistency between the iOS and Android binaries. It is included by both the [`Darwin/ProjectName.xcconfig`](#ProjectName.xcconfig) and [`Android/settings.gradle.kts`](#settings.gradle.kts) files.

See also: [Configuration Metadata](/docs/development-topics/#configuration-with-skipenv)

### `Sources/<Module>/<Module>App.swift` {#App.swift}

The shared app entry point, which launches and configures the app and holds the primary [`ContentView.swift`](#ContentView.swift).

### `Sources/<Module>/ContentView.swift` {#ContentView.swift}

This file is a SwiftUI View file representing the main user interface of the application. In a Skip project, the SwiftUI code in this file will be translated into Jetpack Compose for Android, allowing a single declarative UI definition to drive both platforms.

- Reference: [SwiftUI Views](https://developer.apple.com/documentation/swiftui/view-fundamentals)

### `Sources/<Module>/Skip/skip.yml` {#skip.yml}

This is a YAML Configuration file specific to Skip. It controls module-level settings, such as [Skip mode](/docs/modes/#configuration), bridging configurations, and [Android-specific dependencies](/docs/dependencies/#android).

### `Sources/<Module>/Resources//Module.xcassets` {#Module.xcassets}

This is an Asset Catalog located within a specific Swift module. It holds resources like images, data, and localized strings that are scoped to that module. Skip ensures these assets are processed and made available to both the iOS bundle and the Android res directory.

- Reference: [Apple Developer - Asset Catalogs](https://developer.apple.com/documentation/xcode/managing-assets-with-asset-catalogs)

### `Sources/<Module>/Resources/Localizable.xcstrings` {#Localizable.xcstrings}

This is a String Catalog file used for managing translations. It is the modern format for Darwin localization. Skip converts these strings into Android asserts during the build process which will be used to provide translation parity on both platforms.

- Reference: [Apple Developer - Localizing UI Strings](https://developer.apple.com/documentation/xcode/localizing-and-varying-text-with-a-string-catalog)

### `Sources/<Module>/ViewModel.swift` {#ViewModel.swift}

This file contains the business logic and state for the app, typically utilizing the `@Observable` macro.

### `Tests/<Module>/SkipperModelTests.swift` {#SkipperModelTests.swift}

This file contains test cases used to verify the logic of your modules. For a Skip Fuse project, these tests can be run directly with `skip android test`, and for a Skip Lite project, tests will be transpiled into Kotlin and can be run with `skip test`.

### `Darwin/ProjectName.xcconfig` {#ProjectName.xcconfig}

This is an Xcode Build Configuration file. It provides a way to define build settings (such as compiler flags or search paths) in a plain-text format rather than within the opaque .xcodeproj file, making it easier to manage environment-specific settings.

This configuration file automatically includes the root-level [`Skip.env`](#Skip.env) file, so common properties can be shared between the Darwin and Android projects.

- Reference: [Apple Developer - Configuration Settings File (xcconfig) format](https://help.apple.com/xcode/mac/current/#/dev745c5c974)

### `Darwin/ProjectName.xcodeproj` {#ProjectName.xcodeproj}

This is the Xcode Project file, a bundle containing the configuration, build targets, and file references for the Darwin (iOS/macOS) version of the app. It is the primary entry point for developers focused on the Apple ecosystem.

This project will automatically be included by the generated [`Project.xcworkspace`](#Project.xcworkspace).

:::tip
Many of the project configuration options are specified in the [`Darwin/ProjectName.xcconfig`](#ProjectName.xcconfig). You should generally prefer to manage the project settings in the `.xcconfig` file rather than managing them through the Xcode inferface, since those are human-readable and more amenable to source control management systems like git.
:::

- Reference: [Apple Developer - Xcode Project Structure](https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app)

### `Darwin/Assets.xcassets` {#Assets.xcassets}

This is the Primary Asset Catalog for the Darwin application. It typically contains the application’s icon sets, launch images, and global color assets required for the iOS target.

:::caution
Because it is located in the `Darwin/` folder, this asset catalog is _not_ shared between the platforms. For shared per-module resources, instead use the [`Sources/<Module>/Resources//Module.xcassets`](#Module.xcassets) files.
:::

### `Dawin/Assets.xcassets/AppIcon.appiconset/AppIcon.png` {#AppIcon.png}

This is the Source Image file for the Darwin application icon. 

- Reference: [Apple Developer - App icons](https://developer.apple.com/design/human-interface-guidelines/app-icons)

### `Darwin/Entitlements.plist` {#Entitlements.plist}

This is an XML Property List that defines the capabilities and permissions of the iOS app, such as Push Notifications or application permissions.

- Reference: [Apple Developer - Entitlements](https://developer.apple.com/documentation/bundleresources/entitlements)

### `Darwin/Info.plist` {#Info.plist}

This file is the Information Property List for the iOS application. It contains essential configuration data, such as the bundle identifier, supported orientations, and required hardware capabilities.

- Reference: [Apple Developer - Info.plist Keys](https://developer.apple.com/documentation/bundleresources/information-property-list)

### `Darwin/Sources/Main.swift` {#Main.swift}

This file serves as the Darwin Entry Point. It contains the @main attribute which initializes the SwiftUI App lifecycle for the iOS/macOS version of the project.

The contents of this file will be quite minimal. Like its Kotlin [Main.kt](#Main.kt) counterpart, it mostly calls into the 

Reference: [Apple Developer - App Structure](https://developer.apple.com/documentation/swiftui/app)

### `Darwin/fastlane/Appfile` {#Darwin/fastlane/Appfile}

This directory contains Fastlane configuration files (Deliverfile, Fastfile) used to automate the deployment process for the iOS app, specifically for uploading to the Apple App Store and TestFlight.

- Reference: [Fastlane - iOS Documentation](https://docs.fastlane.tools/getting-started/ios/setup/)

### `Android/app/src/main/kotlin/Main.kt` {#Main.kt}

This is the Android Entry Point. It contains the MainActivity class, which serves as the primary Activity for the Android app. It hosts the transpiled Compose UI and connects the Android lifecycle to the shared Swift logic.

- Reference: [Android Developers - Activities](https://developer.android.com/guide/components/activities/intro-activities)

### `Android/fastlane/Appfile` {#Android/fastlane/Appfile}

This directory contains Fastlane configuration files (`Appfile`, `Fastfile`) used to automate the deployment process for the Android app, specifically for uploading to the Google Play Store.

- Reference: [Fastlane - Android Documentation](https://docs.fastlane.tools/getting-started/android/setup/)

### `Android/settings.gradle.kts` {#settings.gradle.kts}

This is a Gradle Settings file written in Kotlin DSL. It defines the project-level settings and includes the sub-modules (like :app) that make up the Android build.

- Reference: [Gradle - Settings File](https://developer.android.com/build#settings-file)

### `Android/app/build.gradle.kts` {#build.gradle.kts}

This is the Module-level Gradle Build file. It defines the Android-specific build configuration, including SDK versions, signing configurations, and dependencies (including the transpiled Swift modules).

- Reference: [Android Developers - Configure Your Build](https://developer.android.com/build#top-level)

### `Android/app/proguard-rules.pro` {#proguard-rules.pro}

This file contains R8/ProGuard rules for code shrinking and optimization. It ensures that the Kotlin code and its dependencies are properly minified for production.

- Reference: [Enable app optimization](https://developer.android.com/topic/performance/app-optimization/enable-app-optimization)

### `Android/src/main/AndroidManifest.xml` {#AndroidManifest.xml}

This is the Android Manifest file. It describes essential information about the app to the Android build tools, the Android OS, and Google Play, including permissions and the entry point Activity.

Reference: [Android Developers - App Manifest Overview](https://developer.android.com/guide/topics/manifest/manifest-intro)

### `Android/src/main/kotlin/res/mipmap-hdpi/ic_launcher.png` {#ic_launcher.png}

This is a Raster Image Resource representing the app icon for high-density Android screens. These are generated by Skip from the project's source assets to comply with Android's density requirements.

- Reference: [Android Developers - App Icons](https://developer.android.com/studio/write/create-app-icons)

## Project Types

The Skip [Getting Started](/docs/gettingstarted/) guide demonstrates using `skip create` to generate a basic app project interactively, but there are a variety of additional project types. This document discussed the various different project types that can be created and built with Skip.

### Creating an App with `skip init` {#app_development}

The `skip init` command is an alternative to the interactive `skip create` command, which facilitates the initialization of an app with a single, non-interactive command. Run `skip init --help` or see the the [command line reference](/docs/skip-cli/#init) for a complete listing of `skip init` options.

{ /* The most common structure is as a single, dual-platform app project. Creating a dual-platform app project does not prevent you from [customizing](/docs/platformcustomization/) your app for Android, even to the point of e.g. writing your entire Android UI in Kotlin and Compose. But it generally assumes that you'll manage the iOS and Android versions of your app through Xcode as a single logical application. */ }

{ /* The other common structure is to create separate iOS and Android apps that use a set of dual-platform frameworks for shared functionality. Using this option, it is up to you to create and manage the separate iOS and Android applications using Xcode and Android Studio (or your Android IDE of choice), respectively. */ }

### Creating a Standard App

Create a new dual-platform app project with the command:

```console
skip init --native-app --appid=bundle.id project-name AppName
```

:::tip
Passing `--native-app` creates a [Skip Fuse](/docs/status/#skip_fuse) app, and `--transpiled-app` will create a [Skip Lite](/docs/status/#skip_fuse) app.
:::

:::note
Your `appid` must contain at least two words, and each word must be separated by a `.`. It is conventional to use reverse-DNS naming, such as `com.companyname.AppName`. Also make sure that your `project-name` and `AppName` are different. It is conventional to use a lowercase, hyphenated name for your project (which Skip uses to create your app's main SwiftPM package name), and UpperCamelCase for your app name.
:::

Pass the `--open-xcode` argument to immediately open the project in Xcode. For example:

```console
skip init --open-xcode --native-app --appid=bundle.id.HelloSkip hello-skip HelloSkip
```

This will create a `hello-skip/` folder with a new SwiftPM package containing a single module named `HelloSkip`, along with folders named `Darwin` and `Android` and the shared `Skip.env` app configuration file. The `Darwin` folder will contain a `HelloSkip.xcodeproj` project with a `HelloSkip` target, which you can open in Xcode.

:::note
See the [command line reference](/docs/skip-cli/#init) for a complete listing of `skip init` options.
:::

### Creating a Multi-Module App

Skip is designed to accommodate and encourage using multi-module projects. You can create a modularized project by specifying additional module names to `skip init` at the end of the chain. For example: 

```console
skip init --native-app --appid=bundle.id.HelloSkip multi-project HelloSkip HelloModel HelloCore
```

This command will create a SwiftPM project with three modules: `HelloSkip`, `HelloModel`, and `HelloCore`. The heuristics of such module creation is that the modules will all be dependent on their subsequent peer module, with the first module (`HelloSkip`) having an initial dependency on `SkipFuseUI` and the second module depending on `SkipFuse` and `SkipModel`. The `Package.swift` file can be manually edited to shuffle around dependencies, or to add new dependencies on additional frameworks.

### Creating Separate iOS and Android Apps {#separate-apps}

You might choose to share functionality using [dual-platform frameworks](#framework_development), but create separate iOS and Android apps. Some development teams, for example, would like to share common model and business logic layers, but write the UI separately for each platform.

The [Travel Posters](/docs/samples/skipapp-travelposters-native/) sample app provides an example of this pattern. You can read more about it in this [blog post](/blog/shared-swift-model/). It has the following top-level entries:

- `travel-posters-model`: This SwiftPM package builds a [dual-platform framework](#framework_development) containing a common model layer for the iOS and Android apps. Skip ensures that the `@Observable` types you write in Swift can power not only a SwiftUI interface, but a Compose interface as well. See the Development [documentation](/docs/app-development/#observables) for details.
- `iOS`: Directory containing the TravelPosters iOS app and Xcode project, which has `travel-posters-model` as a package dependency.
- `Android`: Directory containing the Android version of the app. The `Android/lib` directory contains exported archives of `travel-posters-model` and the various Skip frameworks that it depends on.
- `TravelPostersNative.xcworkspace`: A workspace that includes both the iOS app and the `travel-posters-model` package.

Use `TravelPostersNative.xcworkspace` to iterate on the iOS app and/or shared model layer. To donate the latest `travel-posters-model` code to the Android app:

```console
skip export --project travel-posters-model -d Android/lib/debug/ --debug
skip export --project travel-posters-model -d Android/lib/release/ --release
```

There are many ways to automate this process, from simple scripting to git submodules to publishing Skip’s generated Android `travel-posters-model` output to a local Maven repository. Use whatever system fits your team's workflow best.

:::note
See the [Deployment](/docs/deployment/#export) chapter for more information on `skip export`.
:::

Additional notes:

- You may need to “Sync Project with Gradle Files” in Android Studio after updating the exported libraries.
- Using an exported library function which has transitive dependencies on additional Android libraries can cause a runtime error. You must ensure that all transitive dependencies are in your own app's `build.gradle.kts`.

---

### Creating a Dual-Platform Framework {#framework_development}

[SkipFuse](/docs/status/#skip_fuse) apps can depend on pure SwiftPM packages as well as pure Kotlin/Java Android libraries. See the chapter covering [dependencies](/docs/dependencies) for details. This section describes how to create a Swift framework whose API can be used from both Swift and Kotlin. The most common use cases are powering [SkipLite](/docs/status/#skip_fuse) transpiled apps or [separate iOS and Android](#separate-apps) apps.

Dual-platform Skip frameworks are pure SwiftPM packages that encapsulate common functionality. Frameworks are simpler than app projects, as they do not need `Darwin/` and `Android/` folders.

<img alt="Framework Development Screenshot" src="https://assets.skip.dev/framework-dev/framework-skip-init.png" style="width: 100%; max-width: 750px;" />

A new framework project can be generated with:

```console
skip init --native-model lib-name ModuleName
```

This will create a new `lib-name` folder containing a `Package.swift` with targets of `ModuleName` and `ModuleNameTests`.

:::tip
Passing `--native-model` creates a [Skip Fuse](/docs/status/#skip_fuse) compiled Swift package. Omit this flag to create a [Skip Lite](/docs/status/#skip_fuse) transpiled package instead. Skip frameworks like [SkipLib](/docs/modules/skip-lib) and [SkipFoundation](/docs/modules/skip-foundation) are examples of transpiled packages, and they are rich sources of examples of various strategies for providing dual-platform functionality.
:::

The generated package can be opened in Xcode, which you can use to build and run the unit tests. Or use `swift build` and `swift test` from the Terminal for headless testing as part of a continuous integration process.

:::note
Due to limitations on Xcode plugins, building your framework target **only** builds the iOS version. To build the Android version, you must run your unit tests. The Android build occurs as part of the testing process.
:::

The `--native-model` option we passed to `skip init` will configure Skip to automatically bridge our model's public API from compiled Swift to Android's [ART](https://source.android.com/docs/core/runtime) Java runtime. This is done through the [`skip.yml`](/docs/modes/#configuration) configuration file included in every Skip module. See the documentation on [bridging](/docs/modes/#bridging) and [`skip.yml`](/docs/modes/#configuration) for details.

### Skip Framework Structure {#framework_structure}

The structure of a Skip framework is exactly the same as any other SwiftPM package:

<FileTree>
- lib-name
    - Package.swift
    - README.md
    - Sources
        - ModuleName
            - ModuleName.swift
            - Resources
                - Localizable.xcstrings
            - Skip
                - skip.yml
    - Tests
        - ModuleNameTests
            - ModuleNameTests.swift
            - XCSkipTests.swift
            - Resources
                - TestData.json
            - Skip
                - skip.yml
</FileTree>

Skip frameworks use a standard `Package.swift` file, with the exception of added dependencies on Skip libraries and use of the `skipstone` plugin for transpilation:

```swift
// Package.swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "lib-name",
    defaultLocalization: "en",
    platforms: [.iOS(.v16), .macOS(.v13), .tvOS(.v16), .watchOS(.v9), .macCatalyst(.v16)],
    products: [
        .library(name: "ModuleName", targets: ["ModuleName"]),
    ],
    dependencies: [
        .package(url: "https://source.skip.tools/skip.git", from: "1.7.0"),
        .package(url: "https://source.skip.tools/skip-fuse.git", from: "1.0.0"),
        .package(url: "https://source.skip.tools/skip-model.git", from: "1.0.0"),
    ],
    targets: [
        .target(name: "ModuleName", , dependencies: [
            .product(name: "SkipFuse", package: "skip-fuse")
            .product(name: "SkipModel", package: "skip-model")
        ], plugins: [
            .plugin(name: "skipstone", package: "skip")
        ]),
        .testTarget(name: "ModuleNameTests", dependencies: ["ModuleName"], plugins: [.plugin(name: "skipstone", package: "skip")]),
    ]
)
```

This configuration includes the dependencies you need to write common model code, including `@Observables` that will work with both SwiftUI and Compose user interfaces. You are free to edit `Package.swift` for your particular needs.

---

## Migrating an Existing App to Skip {#existing_development}

Migrating an existing app to Skip is not trivial. Most apps contain many iOS-only dependencies that make an Android port challenging.

Additionally, when you use `skip create` or `skip init` to create a [new Skip app](#app_development), it handles all the messy details involved in making an app that can build for both iOS and Android. The process is complex enough that we do not recommend trying to migrate an existing Xcode project. Instead, choose one of two options to create an Android version of your existing app:

1. Use `skip create` or `skip init` to create a new Skip app, then add your existing app's dependencies and code.
1. Keep your existing Xcode app, and create a separate Android app using Android Studio or your IDE of choice. Manage the apps separately, but share code by creating [dual-platform frameworks](#framework_development).

Regardless of which option you choose, your first steps are the same:

1. Modularize your app into Swift Package Manager packages, if it isn't already.
1. Starting with your "base" module and working your way up the stack, attempt to get each module building for Android.

We recommend using [Skip Fuse](/docs/status/#skip_fuse) where possible, as it offers greater compatibility with existing Swift code and dependencies.

Porting an app to an entirely new platform isn't easy, even with Skip. Remember that [we're here to help](/docs/help/).

